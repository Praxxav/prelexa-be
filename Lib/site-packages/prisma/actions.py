# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class DocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Document]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Document.prisma().query_raw(
            'SELECT * FROM Document WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Document
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Document.prisma().query_first(
            'SELECT * FROM Document WHERE orgId = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DocumentCreateInput,
        include: Optional[types.DocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Document record.

        Parameters
        ----------
        data
            Document record data
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The created Document record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Document record from just the required fields
        document = await Document.prisma().create(
            data={
                # data to create a Document record
                'orgId': 'ggciceaie',
                'status': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Document records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Document record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Document.prisma().create_many(
            data=[
                {
                    # data to create a Document record
                    'orgId': 'cadfabfehe',
                    'status': 'dgiiaaijj',
                },
                {
                    # data to create a Document record
                    'orgId': 'bfaiacjjfc',
                    'status': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Document record.

        Parameters
        ----------
        where
            Document filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The deleted Document record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Document record.

        Parameters
        ----------
        where
            Document filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The found Document record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Document record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Document filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The found Document record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Document records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Document records returned
        skip
            Ignore the first N results
        where
            Document filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Document]
            The list of all Document records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Document records
        documents = await Document.prisma().find_many(take=10)

        # find the first 5 Document records ordered by the status field
        documents = await Document.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Document record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Document filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Document
            The first Document record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Document record ordered by the insights field
        document = await Document.prisma().find_first(
            skip=1,
            order={
                'insights': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Document record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Document filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Document
            The first Document record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Document record ordered by the fullText field
        document = await Document.prisma().find_first_or_raise(
            skip=1,
            order={
                'fullText': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DocumentUpdateInput,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Document record.

        Parameters
        ----------
        data
            Document record data specifying what to update
        where
            Document filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The updated Document record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        document = await Document.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the Document record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DocumentWhereUniqueInput,
        data: types.DocumentUpsertInput,
        include: Optional[types.DocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Document filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The created or updated Document record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'orgId': 'bfaiacjjfc',
                    'status': 'eigcfgbif',
                },
                'update': {
                    'orgId': 'bfaiacjjfc',
                    'status': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DocumentUpdateManyMutationInput,
        where: types.DocumentWhereInput,
    ) -> int:
        """Update multiple Document records

        Parameters
        ----------
        data
            Document data to update the selected Document records to
        where
            Filter to select the Document records to update

        Returns
        -------
        int
            The total number of Document records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Document records
        total = await Document.prisma().update_many(
            data={
                'filePath': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Document records present in the database

        Parameters
        ----------
        select
            Select the Document fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Document filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Document.prisma().count()

        # results: prisma.types.DocumentCountAggregateOutput
        results = await Document.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> types.DocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> Union[int, types.DocumentCountAggregateOutput]:
        """Count the number of Document records present in the database

        Parameters
        ----------
        select
            Select the Document fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Document filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Document.prisma().count()

        # results: prisma.types.DocumentCountAggregateOutput
        results = await Document.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DocumentWhereInput] = None
    ) -> int:
        """Delete multiple Document records.

        Parameters
        ----------
        where
            Optional Document filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Document records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Document records
        total = await Document.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DocumentScalarFieldKeys'],
        *,
        where: Optional['types.DocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DocumentAvgAggregateInput'] = None,
        sum: Optional['types.DocumentSumAggregateInput'] = None,
        min: Optional['types.DocumentMinAggregateInput'] = None,
        max: Optional['types.DocumentMaxAggregateInput'] = None,
        having: Optional['types.DocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DocumentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DocumentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DocumentGroupByOutput']:
        """Group Document records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Document fields to group records by
        where
            Document filter to select records
        take
            Limit the maximum number of Document records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DocumentGroupByOutput]
            A list of dictionaries representing the Document record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Document records by updatedAt values
        # and count how many records are in each group
        results = await Document.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DocumentVariableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.DocumentVariable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await DocumentVariable.prisma().query_raw(
            'SELECT * FROM DocumentVariable WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.DocumentVariable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await DocumentVariable.prisma().query_first(
            'SELECT * FROM DocumentVariable WHERE documentId = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DocumentVariableCreateInput,
        include: Optional[types.DocumentVariableInclude] = None
    ) -> _PrismaModelT:
        """Create a new DocumentVariable record.

        Parameters
        ----------
        data
            DocumentVariable record data
        include
            Specifies which relations should be loaded on the returned DocumentVariable model

        Returns
        -------
        prisma.models.DocumentVariable
            The created DocumentVariable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a DocumentVariable record from just the required fields
        documentvariable = await DocumentVariable.prisma().create(
            data={
                # data to create a DocumentVariable record
                'documentId': 'bgeecijdgg',
                'name': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DocumentVariableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple DocumentVariable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of DocumentVariable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await DocumentVariable.prisma().create_many(
            data=[
                {
                    # data to create a DocumentVariable record
                    'documentId': 'bgehebiafc',
                    'name': 'bghffegacj',
                },
                {
                    # data to create a DocumentVariable record
                    'documentId': 'bhghchehcc',
                    'name': 'dcgchcbbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DocumentVariableWhereUniqueInput,
        include: Optional[types.DocumentVariableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single DocumentVariable record.

        Parameters
        ----------
        where
            DocumentVariable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned DocumentVariable model

        Returns
        -------
        prisma.models.DocumentVariable
            The deleted DocumentVariable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documentvariable = await DocumentVariable.prisma().delete(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DocumentVariableWhereUniqueInput,
        include: Optional[types.DocumentVariableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique DocumentVariable record.

        Parameters
        ----------
        where
            DocumentVariable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DocumentVariable model

        Returns
        -------
        prisma.models.DocumentVariable
            The found DocumentVariable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documentvariable = await DocumentVariable.prisma().find_unique(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DocumentVariableWhereUniqueInput,
        include: Optional[types.DocumentVariableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique DocumentVariable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            DocumentVariable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DocumentVariable model

        Returns
        -------
        prisma.models.DocumentVariable
            The found DocumentVariable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documentvariable = await DocumentVariable.prisma().find_unique_or_raise(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentVariableWhereInput] = None,
        cursor: Optional[types.DocumentVariableWhereUniqueInput] = None,
        include: Optional[types.DocumentVariableInclude] = None,
        order: Optional[Union[types.DocumentVariableOrderByInput, List[types.DocumentVariableOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentVariableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple DocumentVariable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of DocumentVariable records returned
        skip
            Ignore the first N results
        where
            DocumentVariable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DocumentVariable model
        order
            Order the returned DocumentVariable records by any field
        distinct
            Filter DocumentVariable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.DocumentVariable]
            The list of all DocumentVariable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 DocumentVariable records
        documentvariables = await DocumentVariable.prisma().find_many(take=10)

        # find the first 5 DocumentVariable records ordered by the name field
        documentvariables = await DocumentVariable.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentVariableWhereInput] = None,
        cursor: Optional[types.DocumentVariableWhereUniqueInput] = None,
        include: Optional[types.DocumentVariableInclude] = None,
        order: Optional[Union[types.DocumentVariableOrderByInput, List[types.DocumentVariableOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentVariableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single DocumentVariable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DocumentVariable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DocumentVariable model
        order
            Order the returned DocumentVariable records by any field
        distinct
            Filter DocumentVariable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DocumentVariable
            The first DocumentVariable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DocumentVariable record ordered by the value field
        documentvariable = await DocumentVariable.prisma().find_first(
            skip=1,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentVariableWhereInput] = None,
        cursor: Optional[types.DocumentVariableWhereUniqueInput] = None,
        include: Optional[types.DocumentVariableInclude] = None,
        order: Optional[Union[types.DocumentVariableOrderByInput, List[types.DocumentVariableOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentVariableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single DocumentVariable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DocumentVariable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DocumentVariable model
        order
            Order the returned DocumentVariable records by any field
        distinct
            Filter DocumentVariable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DocumentVariable
            The first DocumentVariable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DocumentVariable record ordered by the confidence field
        documentvariable = await DocumentVariable.prisma().find_first_or_raise(
            skip=1,
            order={
                'confidence': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DocumentVariableUpdateInput,
        where: types.DocumentVariableWhereUniqueInput,
        include: Optional[types.DocumentVariableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single DocumentVariable record.

        Parameters
        ----------
        data
            DocumentVariable record data specifying what to update
        where
            DocumentVariable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned DocumentVariable model

        Returns
        -------
        prisma.models.DocumentVariable
            The updated DocumentVariable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        documentvariable = await DocumentVariable.prisma().update(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                # data to update the DocumentVariable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DocumentVariableWhereUniqueInput,
        data: types.DocumentVariableUpsertInput,
        include: Optional[types.DocumentVariableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            DocumentVariable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned DocumentVariable model

        Returns
        -------
        prisma.models.DocumentVariable
            The created or updated DocumentVariable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documentvariable = await DocumentVariable.prisma().upsert(
            where={
                'id': 'bbbgbhfjge',
            },
            data={
                'create': {
                    'id': 'bbbgbhfjge',
                    'documentId': 'bhghchehcc',
                    'name': 'dcgchcbbf',
                },
                'update': {
                    'documentId': 'bhghchehcc',
                    'name': 'dcgchcbbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DocumentVariableUpdateManyMutationInput,
        where: types.DocumentVariableWhereInput,
    ) -> int:
        """Update multiple DocumentVariable records

        Parameters
        ----------
        data
            DocumentVariable data to update the selected DocumentVariable records to
        where
            Filter to select the DocumentVariable records to update

        Returns
        -------
        int
            The total number of DocumentVariable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all DocumentVariable records
        total = await DocumentVariable.prisma().update_many(
            data={
                'editable': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentVariableWhereInput] = None,
        cursor: Optional[types.DocumentVariableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of DocumentVariable records present in the database

        Parameters
        ----------
        select
            Select the DocumentVariable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DocumentVariable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentVariableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DocumentVariable.prisma().count()

        # results: prisma.types.DocumentVariableCountAggregateOutput
        results = await DocumentVariable.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DocumentVariableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentVariableWhereInput] = None,
        cursor: Optional[types.DocumentVariableWhereUniqueInput] = None,
    ) -> types.DocumentVariableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DocumentVariableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentVariableWhereInput] = None,
        cursor: Optional[types.DocumentVariableWhereUniqueInput] = None,
    ) -> Union[int, types.DocumentVariableCountAggregateOutput]:
        """Count the number of DocumentVariable records present in the database

        Parameters
        ----------
        select
            Select the DocumentVariable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DocumentVariable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentVariableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DocumentVariable.prisma().count()

        # results: prisma.types.DocumentVariableCountAggregateOutput
        results = await DocumentVariable.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DocumentVariableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DocumentVariableWhereInput] = None
    ) -> int:
        """Delete multiple DocumentVariable records.

        Parameters
        ----------
        where
            Optional DocumentVariable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of DocumentVariable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all DocumentVariable records
        total = await DocumentVariable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DocumentVariableScalarFieldKeys'],
        *,
        where: Optional['types.DocumentVariableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DocumentVariableAvgAggregateInput'] = None,
        sum: Optional['types.DocumentVariableSumAggregateInput'] = None,
        min: Optional['types.DocumentVariableMinAggregateInput'] = None,
        max: Optional['types.DocumentVariableMaxAggregateInput'] = None,
        having: Optional['types.DocumentVariableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DocumentVariableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DocumentVariableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DocumentVariableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DocumentVariableGroupByOutput']:
        """Group DocumentVariable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar DocumentVariable fields to group records by
        where
            DocumentVariable filter to select records
        take
            Limit the maximum number of DocumentVariable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DocumentVariableGroupByOutput]
            A list of dictionaries representing the DocumentVariable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group DocumentVariable records by id values
        # and count how many records are in each group
        results = await DocumentVariable.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TemplateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Template]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Template.prisma().query_raw(
            'SELECT * FROM Template WHERE id = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Template
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Template.prisma().query_first(
            'SELECT * FROM Template WHERE orgId = $1',
            'bgiggdidbf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TemplateCreateInput,
        include: Optional[types.TemplateInclude] = None
    ) -> _PrismaModelT:
        """Create a new Template record.

        Parameters
        ----------
        data
            Template record data
        include
            Specifies which relations should be loaded on the returned Template model

        Returns
        -------
        prisma.models.Template
            The created Template record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Template record from just the required fields
        template = await Template.prisma().create(
            data={
                # data to create a Template record
                'orgId': 'caaaedabfc',
                'title': 'bigibebcib',
                'bodyMd': 'bigaiehgcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TemplateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Template records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Template record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Template.prisma().create_many(
            data=[
                {
                    # data to create a Template record
                    'orgId': 'beeifcbebf',
                    'title': 'bgcigfahea',
                    'bodyMd': 'bcejgaggif',
                },
                {
                    # data to create a Template record
                    'orgId': 'idfjadbcc',
                    'title': 'hgdhbjhhj',
                    'bodyMd': 'ecjjjfbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TemplateWhereUniqueInput,
        include: Optional[types.TemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Template record.

        Parameters
        ----------
        where
            Template filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Template model

        Returns
        -------
        prisma.models.Template
            The deleted Template record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        template = await Template.prisma().delete(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TemplateWhereUniqueInput,
        include: Optional[types.TemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Template record.

        Parameters
        ----------
        where
            Template filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Template model

        Returns
        -------
        prisma.models.Template
            The found Template record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        template = await Template.prisma().find_unique(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TemplateWhereUniqueInput,
        include: Optional[types.TemplateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Template record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Template filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Template model

        Returns
        -------
        prisma.models.Template
            The found Template record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        template = await Template.prisma().find_unique_or_raise(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateWhereInput] = None,
        cursor: Optional[types.TemplateWhereUniqueInput] = None,
        include: Optional[types.TemplateInclude] = None,
        order: Optional[Union[types.TemplateOrderByInput, List[types.TemplateOrderByInput]]] = None,
        distinct: Optional[List[types.TemplateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Template records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Template records returned
        skip
            Ignore the first N results
        where
            Template filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Template model
        order
            Order the returned Template records by any field
        distinct
            Filter Template records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Template]
            The list of all Template records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Template records
        templates = await Template.prisma().find_many(take=10)

        # find the first 5 Template records ordered by the title field
        templates = await Template.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TemplateWhereInput] = None,
        cursor: Optional[types.TemplateWhereUniqueInput] = None,
        include: Optional[types.TemplateInclude] = None,
        order: Optional[Union[types.TemplateOrderByInput, List[types.TemplateOrderByInput]]] = None,
        distinct: Optional[List[types.TemplateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Template record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Template filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Template model
        order
            Order the returned Template records by any field
        distinct
            Filter Template records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Template
            The first Template record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Template record ordered by the fileDescription field
        template = await Template.prisma().find_first(
            skip=1,
            order={
                'fileDescription': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TemplateWhereInput] = None,
        cursor: Optional[types.TemplateWhereUniqueInput] = None,
        include: Optional[types.TemplateInclude] = None,
        order: Optional[Union[types.TemplateOrderByInput, List[types.TemplateOrderByInput]]] = None,
        distinct: Optional[List[types.TemplateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Template record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Template filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Template model
        order
            Order the returned Template records by any field
        distinct
            Filter Template records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Template
            The first Template record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Template record ordered by the jurisdiction field
        template = await Template.prisma().find_first_or_raise(
            skip=1,
            order={
                'jurisdiction': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TemplateUpdateInput,
        where: types.TemplateWhereUniqueInput,
        include: Optional[types.TemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Template record.

        Parameters
        ----------
        data
            Template record data specifying what to update
        where
            Template filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Template model

        Returns
        -------
        prisma.models.Template
            The updated Template record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        template = await Template.prisma().update(
            where={
                'id': 'cbachdgfce',
            },
            data={
                # data to update the Template record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TemplateWhereUniqueInput,
        data: types.TemplateUpsertInput,
        include: Optional[types.TemplateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Template filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Template model

        Returns
        -------
        prisma.models.Template
            The created or updated Template record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        template = await Template.prisma().upsert(
            where={
                'id': 'chbfcacbd',
            },
            data={
                'create': {
                    'id': 'chbfcacbd',
                    'orgId': 'idfjadbcc',
                    'title': 'hgdhbjhhj',
                    'bodyMd': 'ecjjjfbae',
                },
                'update': {
                    'orgId': 'idfjadbcc',
                    'title': 'hgdhbjhhj',
                    'bodyMd': 'ecjjjfbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TemplateUpdateManyMutationInput,
        where: types.TemplateWhereInput,
    ) -> int:
        """Update multiple Template records

        Parameters
        ----------
        data
            Template data to update the selected Template records to
        where
            Filter to select the Template records to update

        Returns
        -------
        int
            The total number of Template records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Template records
        total = await Template.prisma().update_many(
            data={
                'originalDocumentId': 'efggddide'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateWhereInput] = None,
        cursor: Optional[types.TemplateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Template records present in the database

        Parameters
        ----------
        select
            Select the Template fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Template filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TemplateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Template.prisma().count()

        # results: prisma.types.TemplateCountAggregateOutput
        results = await Template.prisma().count(
            select={
                '_all': True,
                'docType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TemplateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateWhereInput] = None,
        cursor: Optional[types.TemplateWhereUniqueInput] = None,
    ) -> types.TemplateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TemplateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateWhereInput] = None,
        cursor: Optional[types.TemplateWhereUniqueInput] = None,
    ) -> Union[int, types.TemplateCountAggregateOutput]:
        """Count the number of Template records present in the database

        Parameters
        ----------
        select
            Select the Template fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Template filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TemplateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Template.prisma().count()

        # results: prisma.types.TemplateCountAggregateOutput
        results = await Template.prisma().count(
            select={
                '_all': True,
                'similarityTags': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TemplateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TemplateWhereInput] = None
    ) -> int:
        """Delete multiple Template records.

        Parameters
        ----------
        where
            Optional Template filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Template records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Template records
        total = await Template.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TemplateScalarFieldKeys'],
        *,
        where: Optional['types.TemplateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TemplateAvgAggregateInput'] = None,
        sum: Optional['types.TemplateSumAggregateInput'] = None,
        min: Optional['types.TemplateMinAggregateInput'] = None,
        max: Optional['types.TemplateMaxAggregateInput'] = None,
        having: Optional['types.TemplateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TemplateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TemplateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TemplateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TemplateGroupByOutput']:
        """Group Template records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Template fields to group records by
        where
            Template filter to select records
        take
            Limit the maximum number of Template records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TemplateGroupByOutput]
            A list of dictionaries representing the Template record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Template records by bodyMd values
        # and count how many records are in each group
        results = await Template.prisma().group_by(
            ['bodyMd'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TemplateVariableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TemplateVariable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TemplateVariable.prisma().query_raw(
            'SELECT * FROM TemplateVariable WHERE id = $1',
            'caficfigfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TemplateVariable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TemplateVariable.prisma().query_first(
            'SELECT * FROM TemplateVariable WHERE key = $1',
            'bfidgijfjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TemplateVariableCreateInput,
        include: Optional[types.TemplateVariableInclude] = None
    ) -> _PrismaModelT:
        """Create a new TemplateVariable record.

        Parameters
        ----------
        data
            TemplateVariable record data
        include
            Specifies which relations should be loaded on the returned TemplateVariable model

        Returns
        -------
        prisma.models.TemplateVariable
            The created TemplateVariable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TemplateVariable record from just the required fields
        templatevariable = await TemplateVariable.prisma().create(
            data={
                # data to create a TemplateVariable record
                'key': 'ihieecagf',
                'label': 'bghfciaafe',
                'templateId': 'bgchfhgceh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TemplateVariableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TemplateVariable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TemplateVariable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TemplateVariable.prisma().create_many(
            data=[
                {
                    # data to create a TemplateVariable record
                    'key': 'cafeiaccbc',
                    'label': 'gaddfhfh',
                    'templateId': 'gieegcbeg',
                },
                {
                    # data to create a TemplateVariable record
                    'key': 'bgcffadich',
                    'label': 'fcbichhci',
                    'templateId': 'bcggadccgf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TemplateVariableWhereUniqueInput,
        include: Optional[types.TemplateVariableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TemplateVariable record.

        Parameters
        ----------
        where
            TemplateVariable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TemplateVariable model

        Returns
        -------
        prisma.models.TemplateVariable
            The deleted TemplateVariable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        templatevariable = await TemplateVariable.prisma().delete(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TemplateVariableWhereUniqueInput,
        include: Optional[types.TemplateVariableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TemplateVariable record.

        Parameters
        ----------
        where
            TemplateVariable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TemplateVariable model

        Returns
        -------
        prisma.models.TemplateVariable
            The found TemplateVariable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        templatevariable = await TemplateVariable.prisma().find_unique(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TemplateVariableWhereUniqueInput,
        include: Optional[types.TemplateVariableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TemplateVariable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TemplateVariable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TemplateVariable model

        Returns
        -------
        prisma.models.TemplateVariable
            The found TemplateVariable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        templatevariable = await TemplateVariable.prisma().find_unique_or_raise(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateVariableWhereInput] = None,
        cursor: Optional[types.TemplateVariableWhereUniqueInput] = None,
        include: Optional[types.TemplateVariableInclude] = None,
        order: Optional[Union[types.TemplateVariableOrderByInput, List[types.TemplateVariableOrderByInput]]] = None,
        distinct: Optional[List[types.TemplateVariableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TemplateVariable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TemplateVariable records returned
        skip
            Ignore the first N results
        where
            TemplateVariable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TemplateVariable model
        order
            Order the returned TemplateVariable records by any field
        distinct
            Filter TemplateVariable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TemplateVariable]
            The list of all TemplateVariable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TemplateVariable records
        templatevariables = await TemplateVariable.prisma().find_many(take=10)

        # find the first 5 TemplateVariable records ordered by the label field
        templatevariables = await TemplateVariable.prisma().find_many(
            take=5,
            order={
                'label': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TemplateVariableWhereInput] = None,
        cursor: Optional[types.TemplateVariableWhereUniqueInput] = None,
        include: Optional[types.TemplateVariableInclude] = None,
        order: Optional[Union[types.TemplateVariableOrderByInput, List[types.TemplateVariableOrderByInput]]] = None,
        distinct: Optional[List[types.TemplateVariableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TemplateVariable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TemplateVariable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TemplateVariable model
        order
            Order the returned TemplateVariable records by any field
        distinct
            Filter TemplateVariable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TemplateVariable
            The first TemplateVariable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TemplateVariable record ordered by the description field
        templatevariable = await TemplateVariable.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TemplateVariableWhereInput] = None,
        cursor: Optional[types.TemplateVariableWhereUniqueInput] = None,
        include: Optional[types.TemplateVariableInclude] = None,
        order: Optional[Union[types.TemplateVariableOrderByInput, List[types.TemplateVariableOrderByInput]]] = None,
        distinct: Optional[List[types.TemplateVariableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TemplateVariable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TemplateVariable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TemplateVariable model
        order
            Order the returned TemplateVariable records by any field
        distinct
            Filter TemplateVariable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TemplateVariable
            The first TemplateVariable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TemplateVariable record ordered by the example field
        templatevariable = await TemplateVariable.prisma().find_first_or_raise(
            skip=1,
            order={
                'example': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TemplateVariableUpdateInput,
        where: types.TemplateVariableWhereUniqueInput,
        include: Optional[types.TemplateVariableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TemplateVariable record.

        Parameters
        ----------
        data
            TemplateVariable record data specifying what to update
        where
            TemplateVariable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TemplateVariable model

        Returns
        -------
        prisma.models.TemplateVariable
            The updated TemplateVariable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        templatevariable = await TemplateVariable.prisma().update(
            where={
                'id': 'bchehecef',
            },
            data={
                # data to update the TemplateVariable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TemplateVariableWhereUniqueInput,
        data: types.TemplateVariableUpsertInput,
        include: Optional[types.TemplateVariableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TemplateVariable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TemplateVariable model

        Returns
        -------
        prisma.models.TemplateVariable
            The created or updated TemplateVariable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        templatevariable = await TemplateVariable.prisma().upsert(
            where={
                'id': 'jeijcbhfe',
            },
            data={
                'create': {
                    'id': 'jeijcbhfe',
                    'key': 'bgcffadich',
                    'label': 'fcbichhci',
                    'templateId': 'bcggadccgf',
                },
                'update': {
                    'key': 'bgcffadich',
                    'label': 'fcbichhci',
                    'templateId': 'bcggadccgf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TemplateVariableUpdateManyMutationInput,
        where: types.TemplateVariableWhereInput,
    ) -> int:
        """Update multiple TemplateVariable records

        Parameters
        ----------
        data
            TemplateVariable data to update the selected TemplateVariable records to
        where
            Filter to select the TemplateVariable records to update

        Returns
        -------
        int
            The total number of TemplateVariable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TemplateVariable records
        total = await TemplateVariable.prisma().update_many(
            data={
                'required': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateVariableWhereInput] = None,
        cursor: Optional[types.TemplateVariableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TemplateVariable records present in the database

        Parameters
        ----------
        select
            Select the TemplateVariable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TemplateVariable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TemplateVariableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TemplateVariable.prisma().count()

        # results: prisma.types.TemplateVariableCountAggregateOutput
        results = await TemplateVariable.prisma().count(
            select={
                '_all': True,
                'templateId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TemplateVariableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateVariableWhereInput] = None,
        cursor: Optional[types.TemplateVariableWhereUniqueInput] = None,
    ) -> types.TemplateVariableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TemplateVariableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TemplateVariableWhereInput] = None,
        cursor: Optional[types.TemplateVariableWhereUniqueInput] = None,
    ) -> Union[int, types.TemplateVariableCountAggregateOutput]:
        """Count the number of TemplateVariable records present in the database

        Parameters
        ----------
        select
            Select the TemplateVariable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TemplateVariable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TemplateVariableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TemplateVariable.prisma().count()

        # results: prisma.types.TemplateVariableCountAggregateOutput
        results = await TemplateVariable.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TemplateVariableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TemplateVariableWhereInput] = None
    ) -> int:
        """Delete multiple TemplateVariable records.

        Parameters
        ----------
        where
            Optional TemplateVariable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TemplateVariable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TemplateVariable records
        total = await TemplateVariable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TemplateVariableScalarFieldKeys'],
        *,
        where: Optional['types.TemplateVariableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TemplateVariableAvgAggregateInput'] = None,
        sum: Optional['types.TemplateVariableSumAggregateInput'] = None,
        min: Optional['types.TemplateVariableMinAggregateInput'] = None,
        max: Optional['types.TemplateVariableMaxAggregateInput'] = None,
        having: Optional['types.TemplateVariableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TemplateVariableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TemplateVariableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TemplateVariableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TemplateVariableGroupByOutput']:
        """Group TemplateVariable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TemplateVariable fields to group records by
        where
            TemplateVariable filter to select records
        take
            Limit the maximum number of TemplateVariable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TemplateVariableGroupByOutput]
            A list of dictionaries representing the TemplateVariable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TemplateVariable records by enum values
        # and count how many records are in each group
        results = await TemplateVariable.prisma().group_by(
            ['enum'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InstanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Instance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Instance.prisma().query_raw(
            'SELECT * FROM Instance WHERE id = $1',
            'bcciijbibg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Instance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Instance.prisma().query_first(
            'SELECT * FROM Instance WHERE orgId = $1',
            'cffcachfd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InstanceCreateInput,
        include: Optional[types.InstanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Instance record.

        Parameters
        ----------
        data
            Instance record data
        include
            Specifies which relations should be loaded on the returned Instance model

        Returns
        -------
        prisma.models.Instance
            The created Instance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Instance record from just the required fields
        instance = await Instance.prisma().create(
            data={
                # data to create a Instance record
                'orgId': 'bccdfhdigc',
                'templateId': 'febcgjbfj',
                'answersJson': 'bageiegghg',
                'draftMd': 'faidicegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InstanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Instance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Instance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Instance.prisma().create_many(
            data=[
                {
                    # data to create a Instance record
                    'orgId': 'bacecgfhbe',
                    'templateId': 'ihcahiead',
                    'answersJson': 'biheheiajg',
                    'draftMd': 'jbgijghgb',
                },
                {
                    # data to create a Instance record
                    'orgId': 'hgjcghfbi',
                    'templateId': 'icadbcehj',
                    'answersJson': 'jchciaee',
                    'draftMd': 'deeificjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InstanceWhereUniqueInput,
        include: Optional[types.InstanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Instance record.

        Parameters
        ----------
        where
            Instance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Instance model

        Returns
        -------
        prisma.models.Instance
            The deleted Instance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        instance = await Instance.prisma().delete(
            where={
                'id': 'bbcbhebbda',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InstanceWhereUniqueInput,
        include: Optional[types.InstanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Instance record.

        Parameters
        ----------
        where
            Instance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Instance model

        Returns
        -------
        prisma.models.Instance
            The found Instance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        instance = await Instance.prisma().find_unique(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InstanceWhereUniqueInput,
        include: Optional[types.InstanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Instance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Instance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Instance model

        Returns
        -------
        prisma.models.Instance
            The found Instance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        instance = await Instance.prisma().find_unique_or_raise(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InstanceWhereInput] = None,
        cursor: Optional[types.InstanceWhereUniqueInput] = None,
        include: Optional[types.InstanceInclude] = None,
        order: Optional[Union[types.InstanceOrderByInput, List[types.InstanceOrderByInput]]] = None,
        distinct: Optional[List[types.InstanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Instance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Instance records returned
        skip
            Ignore the first N results
        where
            Instance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Instance model
        order
            Order the returned Instance records by any field
        distinct
            Filter Instance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Instance]
            The list of all Instance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Instance records
        instances = await Instance.prisma().find_many(take=10)

        # find the first 5 Instance records ordered by the templateId field
        instances = await Instance.prisma().find_many(
            take=5,
            order={
                'templateId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InstanceWhereInput] = None,
        cursor: Optional[types.InstanceWhereUniqueInput] = None,
        include: Optional[types.InstanceInclude] = None,
        order: Optional[Union[types.InstanceOrderByInput, List[types.InstanceOrderByInput]]] = None,
        distinct: Optional[List[types.InstanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Instance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Instance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Instance model
        order
            Order the returned Instance records by any field
        distinct
            Filter Instance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Instance
            The first Instance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Instance record ordered by the userQuery field
        instance = await Instance.prisma().find_first(
            skip=1,
            order={
                'userQuery': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InstanceWhereInput] = None,
        cursor: Optional[types.InstanceWhereUniqueInput] = None,
        include: Optional[types.InstanceInclude] = None,
        order: Optional[Union[types.InstanceOrderByInput, List[types.InstanceOrderByInput]]] = None,
        distinct: Optional[List[types.InstanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Instance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Instance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Instance model
        order
            Order the returned Instance records by any field
        distinct
            Filter Instance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Instance
            The first Instance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Instance record ordered by the answersJson field
        instance = await Instance.prisma().find_first_or_raise(
            skip=1,
            order={
                'answersJson': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InstanceUpdateInput,
        where: types.InstanceWhereUniqueInput,
        include: Optional[types.InstanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Instance record.

        Parameters
        ----------
        data
            Instance record data specifying what to update
        where
            Instance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Instance model

        Returns
        -------
        prisma.models.Instance
            The updated Instance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        instance = await Instance.prisma().update(
            where={
                'id': 'igaibbfgj',
            },
            data={
                # data to update the Instance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InstanceWhereUniqueInput,
        data: types.InstanceUpsertInput,
        include: Optional[types.InstanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Instance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Instance model

        Returns
        -------
        prisma.models.Instance
            The created or updated Instance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        instance = await Instance.prisma().upsert(
            where={
                'id': 'bggajdcbbi',
            },
            data={
                'create': {
                    'id': 'bggajdcbbi',
                    'orgId': 'hgjcghfbi',
                    'templateId': 'icadbcehj',
                    'answersJson': 'jchciaee',
                    'draftMd': 'deeificjd',
                },
                'update': {
                    'orgId': 'hgjcghfbi',
                    'templateId': 'icadbcehj',
                    'answersJson': 'jchciaee',
                    'draftMd': 'deeificjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InstanceUpdateManyMutationInput,
        where: types.InstanceWhereInput,
    ) -> int:
        """Update multiple Instance records

        Parameters
        ----------
        data
            Instance data to update the selected Instance records to
        where
            Filter to select the Instance records to update

        Returns
        -------
        int
            The total number of Instance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Instance records
        total = await Instance.prisma().update_many(
            data={
                'draftMd': 'fcfhgbjed'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InstanceWhereInput] = None,
        cursor: Optional[types.InstanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Instance records present in the database

        Parameters
        ----------
        select
            Select the Instance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Instance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InstanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Instance.prisma().count()

        # results: prisma.types.InstanceCountAggregateOutput
        results = await Instance.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InstanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InstanceWhereInput] = None,
        cursor: Optional[types.InstanceWhereUniqueInput] = None,
    ) -> types.InstanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InstanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InstanceWhereInput] = None,
        cursor: Optional[types.InstanceWhereUniqueInput] = None,
    ) -> Union[int, types.InstanceCountAggregateOutput]:
        """Count the number of Instance records present in the database

        Parameters
        ----------
        select
            Select the Instance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Instance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InstanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Instance.prisma().count()

        # results: prisma.types.InstanceCountAggregateOutput
        results = await Instance.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InstanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InstanceWhereInput] = None
    ) -> int:
        """Delete multiple Instance records.

        Parameters
        ----------
        where
            Optional Instance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Instance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Instance records
        total = await Instance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InstanceScalarFieldKeys'],
        *,
        where: Optional['types.InstanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InstanceAvgAggregateInput'] = None,
        sum: Optional['types.InstanceSumAggregateInput'] = None,
        min: Optional['types.InstanceMinAggregateInput'] = None,
        max: Optional['types.InstanceMaxAggregateInput'] = None,
        having: Optional['types.InstanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InstanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InstanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InstanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InstanceGroupByOutput']:
        """Group Instance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Instance fields to group records by
        where
            Instance filter to select records
        take
            Limit the maximum number of Instance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InstanceGroupByOutput]
            A list of dictionaries representing the Instance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Instance records by orgId values
        # and count how many records are in each group
        results = await Instance.prisma().group_by(
            ['orgId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DocumentTypeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.DocumentType]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await DocumentType.prisma().query_raw(
            'SELECT * FROM DocumentType WHERE id = $1',
            'hdgcajhjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.DocumentType
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await DocumentType.prisma().query_first(
            'SELECT * FROM DocumentType WHERE name = $1',
            'ejdjahicb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DocumentTypeCreateInput,
        include: Optional[types.DocumentTypeInclude] = None
    ) -> _PrismaModelT:
        """Create a new DocumentType record.

        Parameters
        ----------
        data
            DocumentType record data
        include
            Specifies which relations should be loaded on the returned DocumentType model

        Returns
        -------
        prisma.models.DocumentType
            The created DocumentType record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a DocumentType record from just the required fields
        documenttype = await DocumentType.prisma().create(
            data={
                # data to create a DocumentType record
                'name': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DocumentTypeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple DocumentType records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of DocumentType record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await DocumentType.prisma().create_many(
            data=[
                {
                    # data to create a DocumentType record
                    'name': 'gfeaahdeh',
                },
                {
                    # data to create a DocumentType record
                    'name': 'bjafcgbffc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DocumentTypeWhereUniqueInput,
        include: Optional[types.DocumentTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single DocumentType record.

        Parameters
        ----------
        where
            DocumentType filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned DocumentType model

        Returns
        -------
        prisma.models.DocumentType
            The deleted DocumentType record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documenttype = await DocumentType.prisma().delete(
            where={
                'id': 'hihegjif',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DocumentTypeWhereUniqueInput,
        include: Optional[types.DocumentTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique DocumentType record.

        Parameters
        ----------
        where
            DocumentType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DocumentType model

        Returns
        -------
        prisma.models.DocumentType
            The found DocumentType record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documenttype = await DocumentType.prisma().find_unique(
            where={
                'id': 'bdjidcidac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DocumentTypeWhereUniqueInput,
        include: Optional[types.DocumentTypeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique DocumentType record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            DocumentType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DocumentType model

        Returns
        -------
        prisma.models.DocumentType
            The found DocumentType record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documenttype = await DocumentType.prisma().find_unique_or_raise(
            where={
                'id': 'ifgaaagff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentTypeWhereInput] = None,
        cursor: Optional[types.DocumentTypeWhereUniqueInput] = None,
        include: Optional[types.DocumentTypeInclude] = None,
        order: Optional[Union[types.DocumentTypeOrderByInput, List[types.DocumentTypeOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentTypeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple DocumentType records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of DocumentType records returned
        skip
            Ignore the first N results
        where
            DocumentType filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DocumentType model
        order
            Order the returned DocumentType records by any field
        distinct
            Filter DocumentType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.DocumentType]
            The list of all DocumentType records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 DocumentType records
        documenttypes = await DocumentType.prisma().find_many(take=10)

        # find the first 5 DocumentType records ordered by the category field
        documenttypes = await DocumentType.prisma().find_many(
            take=5,
            order={
                'category': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentTypeWhereInput] = None,
        cursor: Optional[types.DocumentTypeWhereUniqueInput] = None,
        include: Optional[types.DocumentTypeInclude] = None,
        order: Optional[Union[types.DocumentTypeOrderByInput, List[types.DocumentTypeOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentTypeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single DocumentType record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DocumentType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DocumentType model
        order
            Order the returned DocumentType records by any field
        distinct
            Filter DocumentType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DocumentType
            The first DocumentType record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DocumentType record ordered by the description field
        documenttype = await DocumentType.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentTypeWhereInput] = None,
        cursor: Optional[types.DocumentTypeWhereUniqueInput] = None,
        include: Optional[types.DocumentTypeInclude] = None,
        order: Optional[Union[types.DocumentTypeOrderByInput, List[types.DocumentTypeOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentTypeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single DocumentType record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DocumentType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DocumentType model
        order
            Order the returned DocumentType records by any field
        distinct
            Filter DocumentType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DocumentType
            The first DocumentType record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DocumentType record ordered by the fields field
        documenttype = await DocumentType.prisma().find_first_or_raise(
            skip=1,
            order={
                'fields': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DocumentTypeUpdateInput,
        where: types.DocumentTypeWhereUniqueInput,
        include: Optional[types.DocumentTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single DocumentType record.

        Parameters
        ----------
        data
            DocumentType record data specifying what to update
        where
            DocumentType filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned DocumentType model

        Returns
        -------
        prisma.models.DocumentType
            The updated DocumentType record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        documenttype = await DocumentType.prisma().update(
            where={
                'id': 'befcddgjce',
            },
            data={
                # data to update the DocumentType record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DocumentTypeWhereUniqueInput,
        data: types.DocumentTypeUpsertInput,
        include: Optional[types.DocumentTypeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            DocumentType filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned DocumentType model

        Returns
        -------
        prisma.models.DocumentType
            The created or updated DocumentType record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        documenttype = await DocumentType.prisma().upsert(
            where={
                'id': 'bfhdbjjgfd',
            },
            data={
                'create': {
                    'id': 'bfhdbjjgfd',
                    'name': 'bjafcgbffc',
                },
                'update': {
                    'name': 'bjafcgbffc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DocumentTypeUpdateManyMutationInput,
        where: types.DocumentTypeWhereInput,
    ) -> int:
        """Update multiple DocumentType records

        Parameters
        ----------
        data
            DocumentType data to update the selected DocumentType records to
        where
            Filter to select the DocumentType records to update

        Returns
        -------
        int
            The total number of DocumentType records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all DocumentType records
        total = await DocumentType.prisma().update_many(
            data={
                'metadata': 'cabdjadaji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentTypeWhereInput] = None,
        cursor: Optional[types.DocumentTypeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of DocumentType records present in the database

        Parameters
        ----------
        select
            Select the DocumentType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DocumentType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DocumentType.prisma().count()

        # results: prisma.types.DocumentTypeCountAggregateOutput
        results = await DocumentType.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DocumentTypeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentTypeWhereInput] = None,
        cursor: Optional[types.DocumentTypeWhereUniqueInput] = None,
    ) -> types.DocumentTypeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DocumentTypeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentTypeWhereInput] = None,
        cursor: Optional[types.DocumentTypeWhereUniqueInput] = None,
    ) -> Union[int, types.DocumentTypeCountAggregateOutput]:
        """Count the number of DocumentType records present in the database

        Parameters
        ----------
        select
            Select the DocumentType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DocumentType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DocumentType.prisma().count()

        # results: prisma.types.DocumentTypeCountAggregateOutput
        results = await DocumentType.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DocumentTypeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DocumentTypeWhereInput] = None
    ) -> int:
        """Delete multiple DocumentType records.

        Parameters
        ----------
        where
            Optional DocumentType filter to find the records to be deleted

        Returns
        -------
        int
            The total number of DocumentType records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all DocumentType records
        total = await DocumentType.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DocumentTypeScalarFieldKeys'],
        *,
        where: Optional['types.DocumentTypeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DocumentTypeAvgAggregateInput'] = None,
        sum: Optional['types.DocumentTypeSumAggregateInput'] = None,
        min: Optional['types.DocumentTypeMinAggregateInput'] = None,
        max: Optional['types.DocumentTypeMaxAggregateInput'] = None,
        having: Optional['types.DocumentTypeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DocumentTypeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DocumentTypeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DocumentTypeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DocumentTypeGroupByOutput']:
        """Group DocumentType records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar DocumentType fields to group records by
        where
            DocumentType filter to select records
        take
            Limit the maximum number of DocumentType records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DocumentTypeGroupByOutput]
            A list of dictionaries representing the DocumentType record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group DocumentType records by id values
        # and count how many records are in each group
        results = await DocumentType.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatMessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChatMessage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChatMessage.prisma().query_raw(
            'SELECT * FROM ChatMessage WHERE id = $1',
            'faajgfadf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChatMessage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChatMessage.prisma().query_first(
            'SELECT * FROM ChatMessage WHERE orgId = $1',
            'biaagcedjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatMessageCreateInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created ChatMessage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChatMessage record from just the required fields
        chatmessage = await ChatMessage.prisma().create(
            data={
                # data to create a ChatMessage record
                'orgId': 'cahhaghecf',
                'documentId': 'bghcbbcidi',
                'content': 'jcgghhgdj',
                'role': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatMessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChatMessage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChatMessage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChatMessage.prisma().create_many(
            data=[
                {
                    # data to create a ChatMessage record
                    'orgId': 'bhdiaidiaf',
                    'documentId': 'deajegcfi',
                    'content': 'gabahhhjf',
                    'role': 'cjagadcjg',
                },
                {
                    # data to create a ChatMessage record
                    'orgId': 'bifficggej',
                    'documentId': 'bgbbaajbic',
                    'content': 'eegghdhjb',
                    'role': 'daafgidjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The deleted ChatMessage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().delete(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChatMessage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique_or_raise(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChatMessage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N results
        where
            ChatMessage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChatMessage]
            The list of all ChatMessage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChatMessage records
        chatmessages = await ChatMessage.prisma().find_many(take=10)

        # find the first 5 ChatMessage records ordered by the documentId field
        chatmessages = await ChatMessage.prisma().find_many(
            take=5,
            order={
                'documentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChatMessage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the content field
        chatmessage = await ChatMessage.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChatMessage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the role field
        chatmessage = await ChatMessage.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatMessageUpdateInput,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data specifying what to update
        where
            ChatMessage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The updated ChatMessage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().update(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                # data to update the ChatMessage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatMessageWhereUniqueInput,
        data: types.ChatMessageUpsertInput,
        include: Optional[types.ChatMessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChatMessage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created or updated ChatMessage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().upsert(
            where={
                'id': 'bfdgheeegf',
            },
            data={
                'create': {
                    'id': 'bfdgheeegf',
                    'orgId': 'bifficggej',
                    'documentId': 'bgbbaajbic',
                    'content': 'eegghdhjb',
                    'role': 'daafgidjg',
                },
                'update': {
                    'orgId': 'bifficggej',
                    'documentId': 'bgbbaajbic',
                    'content': 'eegghdhjb',
                    'role': 'daafgidjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatMessageUpdateManyMutationInput,
        where: types.ChatMessageWhereInput,
    ) -> int:
        """Update multiple ChatMessage records

        Parameters
        ----------
        data
            ChatMessage data to update the selected ChatMessage records to
        where
            Filter to select the ChatMessage records to update

        Returns
        -------
        int
            The total number of ChatMessage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChatMessage records
        total = await ChatMessage.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatMessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> types.ChatMessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatMessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> Union[int, types.ChatMessageCountAggregateOutput]:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'orgId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatMessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatMessageWhereInput] = None
    ) -> int:
        """Delete multiple ChatMessage records.

        Parameters
        ----------
        where
            Optional ChatMessage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChatMessage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChatMessage records
        total = await ChatMessage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatMessageScalarFieldKeys'],
        *,
        where: Optional['types.ChatMessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatMessageAvgAggregateInput'] = None,
        sum: Optional['types.ChatMessageSumAggregateInput'] = None,
        min: Optional['types.ChatMessageMinAggregateInput'] = None,
        max: Optional['types.ChatMessageMaxAggregateInput'] = None,
        having: Optional['types.ChatMessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatMessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatMessageGroupByOutput']:
        """Group ChatMessage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChatMessage fields to group records by
        where
            ChatMessage filter to select records
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatMessageGroupByOutput]
            A list of dictionaries representing the ChatMessage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChatMessage records by documentId values
        # and count how many records are in each group
        results = await ChatMessage.prisma().group_by(
            ['documentId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models